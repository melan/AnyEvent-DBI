NAME
    AnyEvent::DBI - asynchronous DBI access

SYNOPSIS
       use AnyEvent::DBI;

       my $cv = AnyEvent->condvar;

       my $dbh = new AnyEvent::DBI "DBI:SQLite:dbname=test.db", "", "";

       $dbh->exec ("select * from test where num=?", 10, sub {
          my ($rows, $rv) = @_;

          print "@$_\n"
             for @$rows;

          $cv->broadcast;
       });

       # asynchronously do sth. else here

       $cv->wait;

DESCRIPTION
    This module is an AnyEvent user, you need to make sure that you use and
    run a supported event loop.

    This module implements asynchronous DBI access by forking or executing
    separate "DBI-Server" processes and sending them requests.

    It means that you can run DBI requests in parallel to other tasks.

    The overhead for very simple statements ("select 0") is somewhere around
    120% to 200% (dual/single core CPU) compared to an explicit
    prepare_cached/execute/fetchrow_arrayref/finish combination.

  METHODS
    $dbh = new AnyEvent::DBI $database, $user, $pass, [key => value]...
        Returns a database handle for the given database. Each database
        handle has an associated server process that executes statements in
        order. If you want to run more than one statement in parallel, you
        need to create additional database handles.

        The advantage of this approach is that transactions work as state is
        preserved.

        Example:

           $dbh = new AnyEvent::DBI
                     "DBI:mysql:test;mysql_read_default_file=/root/.my.cnf", "", "";

        Additional key-value pairs can be used to adjust behaviour:

        on_error => $callback->($dbh, $filename, $line, $fatal)
            When an error occurs, then this callback will be invoked. On
            entry, $@ is set to the error message. $filename and $line is
            where the original request was submitted.

            If this callback returns and this was a fatal error ($fatal is
            true) then AnyEvent::DBI die's, otherwise it calls the original
            request callback without any arguments.

            If omitted, then "die" will be called on any errors, fatal or
            not.

    $dbh->exec ("statement", @args, $cb->($rows, $rv, ...))
        Executes the given SQL statement with placeholders replaced by
        @args. The statement will be prepared and cached on the server side,
        so using placeholders is compulsory.

        The callback will be called with the result of "fetchall_arrayref"
        as first argument (or "undef" if the statement wasn't a select
        statement) and the return value of "execute" as second argument.
        Additional arguments might get passed as well.

        If an error occurs and the "on_error" callback returns, then no
        arguments will be passed and $@ contains the error message.

SEE ALSO
    AnyEvent, DBI.

AUTHOR
       Marc Lehmann <schmorp@schmorp.de>
       http://home.schmorp.de/

